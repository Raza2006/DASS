const express = require('express');
const router = express.Router();
const axios = require('axios');
const Event = require('../models/Event');
const User = require('../models/User');
const Registration = require('../models/Registration');
const { protect, allowRoles } = require('../middleware/authMiddleware');

// ── Discord webhook helper ────────────────────────────────────────────────────
async function postDiscordEmbed(webhookUrl, embed) {
  try {
    await axios.post(webhookUrl, { embeds: [embed] });
  } catch (err) {
    console.warn('Discord webhook failed (non-critical):', err.message);
  }
}

// All admin routes require admin role
router.use(protect, allowRoles('admin'));

// ─── Organizer Management ────────────────────────────────────────────────────

// Helper: random alphanumeric string
function randomStr(len) {
  const chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let out = '';
  for (let i = 0; i < len; i++) out += chars[Math.floor(Math.random() * chars.length)];
  return out;
}

function slugify(str) {
  return (str || '').toLowerCase().trim().replace(/[^a-z0-9]/g, '').slice(0, 20) || 'organizer';
}

// POST /api/admin/organizers  - Admin creates an organizer account
// Body: { name, email, password, clubName, category, description, contactEmail, autoGenerate? }
// When autoGenerate=true, email and password are auto-generated by the system.
router.post('/organizers', async (req, res) => {
  try {
    let { name, email, password, clubName, category, description, contactEmail, autoGenerate } = req.body;

    if (!name) return res.status(400).json({ message: 'Name is required' });

    if (autoGenerate) {
      const base   = slugify(clubName || name);
      const suffix = randomStr(5).toLowerCase();
      email    = `${base}.${suffix}@felicity.iiit.ac.in`;
      password = randomStr(10);
    } else {
      if (!email || !password) {
        return res.status(400).json({ message: 'Email and password are required when not auto-generating' });
      }
      if (password.length < 6) {
        return res.status(400).json({ message: 'Password must be at least 6 characters' });
      }
    }

    const existing = await User.findOne({ email: email.toLowerCase() });
    if (existing) return res.status(400).json({ message: 'Email already registered' });

    const placeholderPhone = '9' + String(Date.now()).slice(-9);
    const organizer = await User.create({
      name,
      email:        email.toLowerCase(),
      password,
      role:         'organizer',
      clubName:     clubName     || '',
      category:     category     || '',
      description:  description  || '',
      contactEmail: contactEmail || '',
      contactNumber: placeholderPhone,
    });

    res.status(201).json({
      message:       'Organizer account created',
      autoGenerated: !!autoGenerate,
      credentials: {
        email:    organizer.email,
        password: autoGenerate ? password : undefined, // only expose plaintext for auto-gen
      },
      organizer: {
        _id:          organizer._id,
        name:         organizer.name,
        email:        organizer.email,
        clubName:     organizer.clubName,
        category:     organizer.category,
        description:  organizer.description,
        contactEmail: organizer.contactEmail,
        isDisabled:   organizer.isDisabled,
        isArchived:   organizer.isArchived,
        createdAt:    organizer.createdAt,
      },
    });
  } catch (error) {
    console.error(error);
    res.status(500).json({ message: 'Error creating organizer' });
  }
});

// PATCH /api/admin/organizers/:id/status  - Disable / Enable / Archive / Restore
router.patch('/organizers/:id/status', async (req, res) => {
  try {
    const { action } = req.body; // 'disable' | 'enable' | 'archive' | 'restore'
    const user = await User.findById(req.params.id);
    if (!user) return res.status(404).json({ message: 'User not found' });
    if (user.role !== 'organizer') return res.status(400).json({ message: 'Target must be an organizer' });

    switch (action) {
      case 'disable': user.isDisabled = true;  user.isArchived = false; break;
      case 'enable':  user.isDisabled = false; user.isArchived = false; break;
      case 'archive': user.isArchived = true;  user.isDisabled = false; break;
      case 'restore': user.isArchived = false; user.isDisabled = false; break;
      default: return res.status(400).json({ message: 'Invalid action. Use: disable, enable, archive, restore' });
    }

    await user.save();
    res.json({ message: `Account ${action}d successfully`, isDisabled: user.isDisabled, isArchived: user.isArchived });
  } catch (error) {
    res.status(500).json({ message: 'Error updating organizer status' });
  }
});

// GET /api/admin/organizers  - list all organizer accounts (including archived)
router.get('/organizers', async (req, res) => {
  try {
    const organizers = await User.find({ role: 'organizer' }).select('-password').sort({ createdAt: -1 });
    res.json(organizers);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching organizers' });
  }
});

// PUT /api/admin/users/:id/reset-password  - Admin resets any user's password
router.put('/users/:id/reset-password', async (req, res) => {
  try {
    const { newPassword } = req.body;

    if (!newPassword || newPassword.length < 6) {
      return res.status(400).json({ message: 'New password must be at least 6 characters' });
    }

    const user = await User.findById(req.params.id);
    if (!user) return res.status(404).json({ message: 'User not found' });

    // Admin cannot reset another admin's password (safety)
    if (user.role === 'admin' && user._id.toString() !== req.user._id.toString()) {
      return res.status(403).json({ message: 'Cannot reset another admin\'s password' });
    }

    user.password = newPassword; // will be hashed by pre-save hook
    await user.save();

    res.json({ message: `Password reset successfully for ${user.email}` });
  } catch (error) {
    res.status(500).json({ message: 'Error resetting password' });
  }
});

router.get('/events', async (req, res) => {
  try {
    const events = await Event.find()
      .populate('organizer', 'name email clubName')
      .sort({ createdAt: -1 });
    res.json(events);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching events' });
  }
});

// PUT /api/admin/events/:id/approve  - approve an event
router.put('/events/:id/approve', async (req, res) => {
  try {
    const event = await Event.findById(req.params.id);
    if (!event) return res.status(404).json({ message: 'Event not found' });

    event.status = 'approved';
    await event.save();

    // Discord webhook: notify the organizer's channel that the event is now live
    const organizer = await User.findById(event.organizer).select('discordWebhook clubName name');
    if (organizer?.discordWebhook) {
      const feeText = event.registrationFee > 0 ? `\u20b9${event.registrationFee}` : 'Free';
      const dateText = event.startDate ? new Date(event.startDate).toDateString() : 'TBD';
      await postDiscordEmbed(organizer.discordWebhook, {
        title: `Event Approved and Now Live: ${event.title}`,
        description: event.description ? event.description.slice(0, 200) + (event.description.length > 200 ? '...' : '') : '',
        color: 0x16a34a,
        fields: [
          { name: 'Organizer', value: organizer.clubName || organizer.name, inline: true },
          { name: 'Category', value: event.category || 'General', inline: true },
          { name: 'Date', value: dateText, inline: true },
          { name: 'Venue', value: event.venue || 'TBD', inline: true },
          { name: 'Registration Fee', value: feeText, inline: true },
          { name: 'Max Participants', value: event.maxParticipants > 0 ? String(event.maxParticipants) : 'Unlimited', inline: true },
        ],
        footer: { text: 'Felicity Events Platform — Register now on the portal!' },
        timestamp: new Date().toISOString(),
      });
    }

    res.json({ message: 'Event approved', event });
  } catch (error) {
    res.status(500).json({ message: 'Error approving event' });
  }
});

// PUT /api/admin/events/:id/reject  - reject an event
router.put('/events/:id/reject', async (req, res) => {
  try {
    const event = await Event.findById(req.params.id);
    if (!event) return res.status(404).json({ message: 'Event not found' });

    event.status = 'rejected';
    await event.save();

    res.json({ message: 'Event rejected', event });
  } catch (error) {
    res.status(500).json({ message: 'Error rejecting event' });
  }
});

// DELETE /api/admin/events/:id  - delete any event
router.delete('/events/:id', async (req, res) => {
  try {
    const event = await Event.findById(req.params.id);
    if (!event) return res.status(404).json({ message: 'Event not found' });

    await event.deleteOne();
    await Registration.deleteMany({ event: req.params.id });

    res.json({ message: 'Event deleted' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting event' });
  }
});

// GET /api/admin/users  - see all users
router.get('/users', async (req, res) => {
  try {
    const users = await User.find().select('-password').sort({ createdAt: -1 });
    res.json(users);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching users' });
  }
});

// DELETE /api/admin/users/:id  - delete a user
router.delete('/users/:id', async (req, res) => {
  try {
    const userId = req.params.id;

    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ message: 'User not found' });

    // ✅ remove all registrations created by this user
    await Registration.deleteMany({ participant: userId });

    // ✅ delete user
    await user.deleteOne();

    res.json({ message: 'User and their registrations deleted' });
  } catch (error) {
    res.status(500).json({ message: 'Error deleting user' });
  }
});

// GET /api/admin/registrations  - all registrations with participant + event details
router.get('/registrations', async (req, res) => {
  try {
    const registrations = await Registration.find()
      .populate('event', 'title date venue category')
      .populate('participant', 'name email isIIITStudent')
      .sort({ createdAt: -1 });
    res.json(registrations);
  } catch (error) {
    res.status(500).json({ message: 'Error fetching registrations' });
  }
});

// GET /api/admin/stats  - overview numbers
router.get('/stats', async (req, res) => {
  try {
    const totalParticipants = await User.countDocuments({ role: 'participant' });
    const totalOrganizers = await User.countDocuments({ role: 'organizer' });

    const totalEvents = await Event.countDocuments({ status: 'approved' });
    const pendingEvents = await Event.countDocuments({ status: 'pending' });

    const totalRegistrations = await Registration.countDocuments({ status: 'registered' });
    const totalAttended = await Registration.countDocuments({ status: 'attended' });

    res.json({
      totalParticipants,
      totalOrganizers,
      totalEvents,
      pendingEvents,
      totalRegistrations,
      totalAttended
    });
  } catch (error) {
    res.status(500).json({ message: 'Error fetching stats' });
  }
});

// ─── Password Reset Request Management ───────────────────────────────────────
const bcrypt      = require('bcryptjs');
const PasswordResetRequest = require('../models/PasswordResetRequest');

function genPassword(len = 12) {
  const chars = 'abcdefghjkmnpqrstuvwxyzABCDEFGHJKMNPQRSTUVWXYZ23456789!@#$';
  let out = '';
  for (let i = 0; i < len; i++) out += chars[Math.floor(Math.random() * chars.length)];
  return out;
}

// GET /api/admin/password-resets  — list all requests (newest first)
router.get('/password-resets', async (req, res) => {
  try {
    const reqs = await PasswordResetRequest.find()
      .populate('organizer', 'name email clubName')
      .populate('resolvedBy', 'name')
      .sort({ createdAt: -1 });
    res.json(reqs);
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});

// PATCH /api/admin/password-resets/:id/approve
router.patch('/password-resets/:id/approve', async (req, res) => {
  try {
    const { adminComment } = req.body;
    const request = await PasswordResetRequest.findById(req.params.id).populate('organizer', '_id email name');
    if (!request) return res.status(404).json({ message: 'Request not found' });
    if (request.status !== 'pending') return res.status(400).json({ message: 'Request already resolved' });

    const newPassword = genPassword(12);
    const hashed      = await bcrypt.hash(newPassword, 10);

    // Update organizer password
    await User.findByIdAndUpdate(request.organizer._id, { password: hashed });

    request.status            = 'approved';
    request.adminComment      = adminComment || '';
    request.generatedPassword = newPassword;  // plain-text for admin to share
    request.resolvedAt        = new Date();
    request.resolvedBy        = req.user._id;
    await request.save();

    res.json({ message: 'Approved. Share the generated password with the organizer.', generatedPassword: newPassword, request });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});

// PATCH /api/admin/password-resets/:id/reject
router.patch('/password-resets/:id/reject', async (req, res) => {
  try {
    const { adminComment } = req.body;
    const request = await PasswordResetRequest.findById(req.params.id);
    if (!request) return res.status(404).json({ message: 'Request not found' });
    if (request.status !== 'pending') return res.status(400).json({ message: 'Request already resolved' });

    request.status       = 'rejected';
    request.adminComment = adminComment || '';
    request.resolvedAt   = new Date();
    request.resolvedBy   = req.user._id;
    await request.save();

    res.json({ message: 'Request rejected.', request });
  } catch (err) {
    res.status(500).json({ message: err.message });
  }
});

module.exports = router;
